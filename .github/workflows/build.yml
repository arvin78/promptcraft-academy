name: Build Android APK from ZIP

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Find and extract ZIP
        id: prep
        shell: bash
        run: |
          set -euo pipefail

          ZIP="$(ls -1 *.zip 2>/dev/null | head -n 1 || true)"
          if [ -z "$ZIP" ]; then
            echo "❌ No .zip found in repo root. Put your project zip in repo root." >&2
            exit 1
          fi

          echo "zip=$ZIP" >> "$GITHUB_OUTPUT"

          rm -rf extracted
          mkdir -p extracted
          unzip -q "$ZIP" -d extracted

          ROOT="$(python3 - <<'PY'
          import os
          for dirpath, _, filenames in os.walk("extracted"):
              if "pubspec.yaml" in filenames:
                  print(dirpath)
                  break
          PY
          )"

          if [ -z "$ROOT" ]; then
            echo "❌ pubspec.yaml not found inside zip" >&2
            find extracted -maxdepth 4 -type f | head -n 200
            exit 1
          fi

          echo "root=$ROOT" >> "$GITHUB_OUTPUT"
          echo "✅ Flutter root: $ROOT"
          ls -la "$ROOT" | head -n 50

      - name: Auto-fix pubspec.yaml (common YAML mistakes)
        shell: bash
        env:
          ROOT: ${{ steps.prep.outputs.root }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import os, re, pathlib
          p = pathlib.Path(os.environ["ROOT"]) / "pubspec.yaml"
          txt = p.read_text(encoding="utf-8", errors="replace")

          # Fix a very common broken pattern:
          # dependencies:
          #   (missing "flutter:" key)
          #   sdk: flutter
          lines = txt.splitlines()
          out = []
          i = 0
          changed = False

          while i < len(lines):
              line = lines[i]

              if re.match(r'^\s*sdk\s*:\s*flutter\s*$', line):
                  indent = len(line) - len(line.lstrip(' '))
                  # Find previous meaningful line
                  j = len(out) - 1
                  while j >= 0 and (out[j].strip() == "" or out[j].lstrip().startswith("#")):
                      j -= 1
                  prev = out[j].strip() if j >= 0 else ""
                  if prev != "flutter:":
                      out.append(" " * indent + "flutter:")
                      out.append(" " * (indent + 2) + "sdk: flutter")
                      changed = True
                      i += 1
                      continue

              out.append(line)
              i += 1

          fixed = "\n".join(out) + ("\n" if txt.endswith("\n") else "")
          if changed:
              p.write_text(fixed, encoding="utf-8")
              print("✅ Patched pubspec.yaml")
          else:
              print("✅ No pubspec.yaml changes needed")
          PY

      - name: Patch ProgressStore (fix missing methods so build won't fail)
        shell: bash
        env:
          ROOT: ${{ steps.prep.outputs.root }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import os, pathlib, sys

          root = pathlib.Path(os.environ["ROOT"])
          candidates = list(root.rglob("progress_store.dart"))
          if not candidates:
              print("⚠️ progress_store.dart not found, skipping")
              sys.exit(0)

          p = candidates[0]

          new_store = r"""import 'package:flutter/foundation.dart';

          class ProgressStore extends ChangeNotifier {
            bool _initialized = false;

            final Set<String> completedLessons = <String>{};
            final Map<String, int> quizScores = <String, int>{};

            // Raw spaced-repetition data (stored as JSON strings by key).
            final Map<String, String> _srsRaw = <String, String>{};

            // Error logs (free-form maps).
            final List<Map<String, dynamic>> _errorLogs = <Map<String, dynamic>>[];

            bool get initialized => _initialized;

            Future<void> init() async {
              _initialized = true;
              notifyListeners();
            }

            bool isLessonCompleted(String lessonId) => completedLessons.contains(lessonId);

            Future<void> completeLesson(String lessonId) async {
              completedLessons.add(lessonId);
              notifyListeners();
            }

            Future<void> uncompleteLesson(String lessonId) async {
              completedLessons.remove(lessonId);
              notifyListeners();
            }

            int getQuizScore(String quizId) => quizScores[quizId] ?? 0;

            Future<void> setQuizScore(String quizId, int score) async {
              quizScores[quizId] = score;
              notifyListeners();
            }

            // === Compatibility methods (called elsewhere in the app) ===

            Future<void> resetAll() async {
              completedLessons.clear();
              quizScores.clear();
              _srsRaw.clear();
              _errorLogs.clear();
              notifyListeners();
            }

            Future<void> clearErrorLogs() async {
              _errorLogs.clear();
              notifyListeners();
            }

            List<Map<String, dynamic>> getErrorLogs() => List.unmodifiable(_errorLogs);

            Future<void> addErrorLog(Map<String, dynamic> log) async {
              _errorLogs.add(Map<String, dynamic>.from(log));
              if (_errorLogs.length > 200) {
                _errorLogs.removeRange(0, _errorLogs.length - 200);
              }
              notifyListeners();
            }

            String? getSrsRaw(String key) => _srsRaw[key];

            Future<void> setSrsRaw(String key, String value) async {
              _srsRaw[key] = value;
              notifyListeners();
            }
          }
          """.replaceFirst("\n          ", "\n").replaceAll("\n          ", "\n");

          p.write_text(new_store, encoding="utf-8")
          print("✅ Patched:", p)
          PY

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: stable
          cache: true

      - name: Flutter pub get
        shell: bash
        run: |
          set -euo pipefail
          cd "${{ steps.prep.outputs.root }}"
          flutter --version
          flutter pub get

      - name: Build APK (debug + split per ABI) and save log
        shell: bash
        run: |
          set -euo pipefail
          cd "${{ steps.prep.outputs.root }}"
          flutter build apk --debug --split-per-abi -v 2>&1 | tee flutter_build.log

      - name: Extract REAL error cause -> ERROR_SUMMARY.txt
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          ROOT="${{ steps.prep.outputs.root }}"
          python3 - <<'PY'
          import pathlib, re
          root = pathlib.Path("${ROOT}")
          log = root / "flutter_build.log"
          out = root / "ERROR_SUMMARY.txt"

          if not log.exists():
              out.write_text("No flutter_build.log found.\n", encoding="utf-8")
              print("⚠️ No log file.")
              raise SystemExit(0)

          txt = log.read_text(encoding="utf-8", errors="replace").splitlines()

          # Keep last 1200 lines and pick the first strong error window
          tail = txt[-1200:]
          patterns = [
              r"^.*\berror\b.*$",
              r"^.*\bFAILURE\b.*$",
              r"^.*\bException\b.*$",
              r"^.*Target kernel_snapshot_program failed.*$",
              r"^.*Process completed with exit code.*$",
          ]

          hits = []
          for i, line in enumerate(tail):
              for pat in patterns:
                  if re.search(pat, line, flags=re.IGNORECASE):
                      hits.append(i)
                      break

          if hits:
              start = max(0, hits[0] - 60)
              chunk = tail[start:start + 260]
          else:
              chunk = tail[-260:]

          out.write_text("\n".join(chunk) + "\n", encoding="utf-8")
          print("✅ Wrote ERROR_SUMMARY.txt")
          PY

      - name: Collect APKs
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          ROOT="${{ steps.prep.outputs.root }}"
          mkdir -p out
          cp -v "$ROOT/build/app/outputs/flutter-apk/"*.apk out/ || true
          cp -v "$ROOT/flutter_build.log" out/ || true
          cp -v "$ROOT/ERROR_SUMMARY.txt" out/ || true
          ls -la out || true

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: android-build
          path: out/*
          if-no-files-found: ignore
