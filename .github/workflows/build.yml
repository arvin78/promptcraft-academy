name: Build Android APK (ZIP + AutoPatch v2)

on:
  workflow_dispatch:
  push:
    branches: [ "main" ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install unzip + python
        run: |
          sudo apt-get update
          sudo apt-get install -y unzip python3

      - name: Pick ZIP (any name) and copy to safe.zip
        shell: bash
        run: |
          set -e
          ZIP="$(find . -maxdepth 6 -type f -iname '*.zip' | head -n 1 || true)"
          if [ -z "$ZIP" ]; then
            echo "ERROR: No ZIP found in repo."
            ls -lah
            exit 1
          fi
          echo "Found ZIP: $ZIP"
          cp "$ZIP" safe.zip
          ls -lah safe.zip

      - name: Extract ZIP
        shell: bash
        run: |
          set -e
          rm -rf extracted
          mkdir -p extracted
          unzip -q safe.zip -d extracted
          echo "Extracted:"
          ls -lah extracted | head -n 50

      - name: Find Flutter root (pubspec.yaml)
        id: root
        shell: bash
        run: |
          set -e
          ROOT="$(find extracted -maxdepth 10 -type f -name pubspec.yaml -print -quit | xargs -r dirname)"
          if [ -z "$ROOT" ]; then
            echo "ERROR: pubspec.yaml not found after unzip."
            find extracted -maxdepth 10 -name pubspec.yaml -print || true
            exit 1
          fi
          echo "root=$ROOT" >> "$GITHUB_OUTPUT"
          echo "Project root: $ROOT"

      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "17"

      - name: Setup Flutter (stable)
        uses: subosito/flutter-action@v2
        with:
          channel: "stable"
          cache: true

      - name: AutoPatch v2 (no code editing needed)
        shell: bash
        env:
          ROOT: ${{ steps.root.outputs.root }}
        run: |
          set -e
          echo "AutoPatch root: $ROOT"
          python3 - <<'PY'
          import os, re
          from pathlib import Path

          root = Path(os.environ["ROOT"])

          def find_one(filename: str):
            hits = list(root.rglob(filename))
            return hits[0] if hits else None

          def safe_read(p: Path):
            return p.read_text(encoding="utf-8", errors="ignore")

          def safe_write(p: Path, text: str):
            p.parent.mkdir(parents=True, exist_ok=True)
            p.write_text(text, encoding="utf-8")

          print("== AutoPatch v2 start ==")

          # 1) Fix broken quotes in error_lab_engine.dart
          p = find_one("error_lab_engine.dart")
          if p:
            txt = safe_read(p)
            before = txt
            # Escape patterns like '...'
            txt = re.sub(r"'(\.\.\.)'", r"\\'\1\\'", txt)
            if txt != before:
              safe_write(p, txt)
              print("Patched quotes:", p)
            else:
              print("No quote patch needed:", p)
          else:
            print("Skipped: error_lab_engine.dart not found")

          # 2) Fix CardTheme -> CardThemeData in app_theme.dart
          p = find_one("app_theme.dart")
          if p:
            txt = safe_read(p)
            before = txt
            # Replace only where CardTheme is used as cardTheme value
            txt = txt.replace("cardTheme: CardTheme(", "cardTheme: CardThemeData(")
            txt = txt.replace("cardTheme: const CardTheme(", "cardTheme: const CardThemeData(")
            if txt != before:
              safe_write(p, txt)
              print("Patched CardThemeData:", p)
            else:
              print("No CardTheme patch needed:", p)
          else:
            print("Skipped: app_theme.dart not found")

          # 3) Fix prompt_builder_page.dart (context controller naming bug)
          p = find_one("prompt_builder_page.dart")
          if p:
            txt = safe_read(p)
            before = txt
            # Rename controller variable `context` -> `ctx`
            txt = re.sub(r"\bfinal\s+context\s*=\s*TextEditingController", "final ctx = TextEditingController", txt)
            txt = re.sub(r"\bvar\s+context\s*=\s*TextEditingController", "var ctx = TextEditingController", txt)
            txt = re.sub(r"\bcontext\.text\b", "ctx.text", txt)
            txt = re.sub(r"\bcontext\.dispose\(\)", "ctx.dispose()", txt)
            txt = re.sub(r"_field\(\s*'کانتکست'\s*,\s*context\s*,", "_field('کانتکست', ctx,", txt)
            if txt != before:
              safe_write(p, txt)
              print("Patched prompt_builder_page.dart:", p)
            else:
              print("No prompt builder patch needed:", p)
          else:
            print("Skipped: prompt_builder_page.dart not found")

          # 4) Replace ProgressStore with a compatible version (adds init + completedLessons + quizScores)
          p = find_one("progress_store.dart")
          if p:
            new_store = """import 'package:flutter/foundation.dart';

          class ProgressStore extends ChangeNotifier {
            bool _initialized = false;

            final Set<String> completedLessons = <String>{};
            final Map<String, int> quizScores = <String, int>{};

            Future<void> init() async {
              _initialized = true;
            }

            bool get isInitialized => _initialized;

            bool isLessonCompleted(String lessonId) => completedLessons.contains(lessonId);

            Future<void> completeLesson(String lessonId) async {
              completedLessons.add(lessonId);
              notifyListeners();
            }

            Future<void> uncompleteLesson(String lessonId) async {
              completedLessons.remove(lessonId);
              notifyListeners();
            }

            Future<void> setQuizScore(String quizId, int score) async {
              final prev = quizScores[quizId] ?? -1;
              if (score > prev) {
                quizScores[quizId] = score;
                notifyListeners();
              }
            }

            // Extra helpers (safe)
            Future<Set<String>> getCompletedLessonIds() async => completedLessons;
          }
          """
            safe_write(p, new_store)
            print("Replaced ProgressStore:", p)
          else:
            print("Skipped: progress_store.dart not found")

          # 5) Ensure Course type exists (append to models/course.dart if missing)
          p = find_one("course.dart")
          if p:
            txt = safe_read(p)
            if "class Course" not in txt:
              addon = """

          // --- AutoPatch v2: add Course wrapper (dashboard expects it) ---
          class Course {
            final String id;
            final String title;
            final List<Module> modules;

            const Course({
              required this.id,
              required this.title,
              required this.modules,
            });

            List<Lesson> get allLessons =>
                modules.expand((m) => m.lessons).toList(growable: false);
          }
          """
              safe_write(p, txt + addon)
              print("Appended Course to:", p)
            else:
              print("Course already exists:", p)
          else:
            print("Skipped: course.dart not found")

          # 6) Add compat methods to ContentRepository via extension (loadCourse + loadLessonMd)
          p = find_one("content_repository.dart")
          if p:
            txt = safe_read(p)
            if "extension ContentRepositoryCompat" not in txt:
              ext = """

          // --- AutoPatch v2: compat methods used by UI ---
          extension ContentRepositoryCompat on ContentRepository {
            Future<Course> loadCourse() async {
              // Try to use existing loadModulesFa() if present
              final dynamic self = this;
              try {
                final modules = await self.loadModulesFa();
                return Course(id: 'course', title: 'PromptCraft Academy', modules: (modules as List).cast<Module>());
              } catch (_) {
                // Minimal fallback
                return Course(id: 'course', title: 'PromptCraft Academy', modules: const <Module>[]);
              }
            }

            Future<String> loadLessonMd(String lessonId) async {
              // Try to use existing loadLessonMarkdown() if present
              final dynamic self = this;
              try {
                return await self.loadLessonMarkdown(lessonId);
              } catch (_) {
                return 'محتوای این درس پیدا نشد (lessonId=$lessonId).';
              }
            }
          }
          """
              safe_write(p, txt + ext)
              print("Appended ContentRepositoryCompat:", p)
            else:
              print("ContentRepositoryCompat already exists:", p)
          else:
            print("Skipped: content_repository.dart not found")

          print("== AutoPatch v2 done ==")
          PY

      - name: Pub get
        working-directory: ${{ steps.root.outputs.root }}
        run: flutter pub get

      - name: Build RELEASE APKs (split per ABI + universal) + log
        working-directory: ${{ steps.root.outputs.root }}
        shell: bash
        run: |
          set -o pipefail
          flutter build apk --release --split-per-abi 2>&1 | tee flutter_build.log
          flutter build apk --release 2>&1 | tee -a flutter_build.log
          ls -lah build/app/outputs/flutter-apk || true

      - name: Collect artifacts
        shell: bash
        env:
          ROOT: ${{ steps.root.outputs.root }}
        run: |
          set -e
          mkdir -p artifacts
          cp -f "$ROOT/flutter_build.log" artifacts/flutter_build.log || true
          cp -f "$ROOT/build/app/outputs/flutter-apk/"*.apk artifacts/ || true
          ls -lah artifacts

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: android-apk
          path: artifacts/*
