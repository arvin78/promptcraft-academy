name: Build Android APK (FINAL v3 - ZIP + Bootstrap + Full AutoPatch)

on:
  workflow_dispatch:
  push:
    branches: [ "main" ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "17"

      - name: Setup Flutter (stable)
        uses: subosito/flutter-action@v2
        with:
          channel: "stable"
          cache: true

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y unzip python3 rsync

      - name: Pick ZIP (newest)
        shell: bash
        run: |
          set -e
          ZIP="$(find . -maxdepth 8 -type f -iname '*.zip' -printf '%T@ %p\n' | sort -nr | head -n 1 | cut -d' ' -f2- || true)"
          if [ -z "$ZIP" ]; then
            echo "ERROR: No ZIP found in repo."
            find . -maxdepth 4 -type f -print
            exit 1
          fi
          echo "Found ZIP: $ZIP"
          cp "$ZIP" safe.zip
          ls -lah safe.zip

      - name: Extract ZIP
        shell: bash
        run: |
          set -e
          rm -rf extracted
          mkdir -p extracted
          unzip -q safe.zip -d extracted
          echo "Extracted top:"
          ls -lah extracted | head -n 80

      - name: Find Flutter root (pubspec.yaml)
        id: unpacked
        shell: bash
        run: |
          set -e
          ROOT="$(find extracted -maxdepth 12 -type f -name pubspec.yaml -print -quit | xargs -r dirname)"
          if [ -z "$ROOT" ]; then
            echo "ERROR: pubspec.yaml not found after unzip."
            find extracted -maxdepth 12 -name pubspec.yaml -print || true
            exit 1
          fi
          echo "root=$ROOT" >> "$GITHUB_OUTPUT"
          echo "Unpacked root: $ROOT"

      - name: Bootstrap Android project if missing/unsupported
        id: root
        shell: bash
        env:
          ROOT: ${{ steps.unpacked.outputs.root }}
        run: |
          set -e
          echo "Checking Android scaffold in: $ROOT"

          if [ -d "$ROOT/android" ] && ( [ -f "$ROOT/android/build.gradle" ] || [ -f "$ROOT/android/build.gradle.kts" ] ); then
            echo "Android folder exists. Using original project."
            echo "root=$ROOT" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Android folder missing/unsupported => Creating fresh Flutter Android scaffold (recommended fix)..."
          rm -rf workapp
          flutter create -t app workapp --platforms=android --org com.promptcraft.academy

          # Copy project content on top, keep generated android/
          rsync -a \
            --exclude=android --exclude=ios --exclude=linux --exclude=macos --exclude=windows --exclude=web \
            --exclude=.dart_tool --exclude=build \
            "$ROOT"/ workapp/

          echo "Using bootstrapped project: workapp"
          echo "root=workapp" >> "$GITHUB_OUTPUT"

      - name: Full AutoPatch (fix CURRENT errors)
        shell: bash
        env:
          ROOT: ${{ steps.root.outputs.root }}
        run: |
          set -e
          echo "AutoPatch root: $ROOT"
          python3 - <<'PY'
          import os, re, textwrap
          from pathlib import Path
          from datetime import datetime

          root = Path(os.environ["ROOT"])
          report = []

          def find_one(filename: str):
            hits = list(root.rglob(filename))
            return hits[0] if hits else None

          def safe_read(p: Path):
            return p.read_text(encoding="utf-8", errors="ignore")

          def safe_write(p: Path, text: str):
            p.parent.mkdir(parents=True, exist_ok=True)
            p.write_text(text, encoding="utf-8")

          def log(msg: str):
            report.append(msg)
            print(msg)

          log("== AutoPatch FINAL v3 start ==")

          # A) Fix Dart quote issues (safe)
          p = find_one("error_lab_engine.dart")
          if p:
            txt = safe_read(p)
            before = txt
            txt = txt.replace("داخل '...'.", "داخل \\'...\\'.")
            txt = txt.replace("نه '...'.", "نه \\'...\\'.")
            if txt != before:
              safe_write(p, txt)
              log(f"Patched quotes: {p}")
            else:
              log(f"No quote patch needed: {p}")
          else:
            log("Skipped: error_lab_engine.dart not found")

          # B) Fix CardTheme -> CardThemeData (Flutter 3.x compatibility)
          p = find_one("app_theme.dart")
          if p:
            txt = safe_read(p)
            before = txt
            txt = txt.replace("cardTheme: CardTheme(", "cardTheme: CardThemeData(")
            txt = txt.replace("cardTheme: const CardTheme(", "cardTheme: const CardThemeData(")
            if txt != before:
              safe_write(p, txt)
              log(f"Patched CardThemeData: {p}")
            else:
              log(f"No CardTheme patch needed: {p}")
          else:
            log("Skipped: app_theme.dart not found")

          # C) Fix prompt_builder_page.dart context controller naming (common collision)
          p = find_one("prompt_builder_page.dart")
          if p:
            txt = safe_read(p)
            before = txt
            txt = re.sub(r"\bfinal\s+context\s*=\s*TextEditingController", "final ctx = TextEditingController", txt)
            txt = re.sub(r"\bvar\s+context\s*=\s*TextEditingController", "var ctx = TextEditingController", txt)
            txt = re.sub(r"\bcontext\.text\b", "ctx.text", txt)
            txt = re.sub(r"\bcontext\.dispose\(\)", "ctx.dispose()", txt)
            txt = re.sub(r"_field\(\s*'کانتکست'\s*,\s*context\s*,", "_field('کانتکست', ctx,", txt)
            if txt != before:
              safe_write(p, txt)
              log(f"Patched prompt_builder_page.dart: {p}")
            else:
              log(f"No prompt builder patch needed: {p}")
          else:
            log("Skipped: prompt_builder_page.dart not found")

          # D) Replace ProgressStore with FULL API used by the app (fixes your current errors)
          p = find_one("progress_store.dart")
          if p:
            new_store = textwrap.dedent("""\
              import 'package:flutter/foundation.dart';

              class ProgressStore extends ChangeNotifier {
                bool _initialized = false;

                final Set<String> completedLessons = <String>{};
                final Map<String, int> quizScores = <String, int>{};

                final List<String> _errorLogs = <String>[];
                String _srsRaw = '{}';

                Future<void> init() async {
                  _initialized = true;
                }

                bool get isInitialized => _initialized;

                // Lessons
                bool isLessonCompleted(String lessonId) => completedLessons.contains(lessonId);

                Future<void> completeLesson(String lessonId) async {
                  completedLessons.add(lessonId);
                  notifyListeners();
                }

                Future<void> uncompleteLesson(String lessonId) async {
                  completedLessons.remove(lessonId);
                  notifyListeners();
                }

                Future<Set<String>> getCompletedLessonIds() async => completedLessons;

                Future<Map<String, bool>> loadLessonCompletion() async {
                  return {for (final id in completedLessons) id: true};
                }

                // Quiz
                Future<void> setQuizScore(String quizId, int score) async {
                  final prev = quizScores[quizId] ?? -1;
                  if (score > prev) {
                    quizScores[quizId] = score;
                    notifyListeners();
                  }
                }

                // Error logs (Settings & Error Lab)
                Future<void> addErrorLog(String text) async {
                  final ts = DateTime.now().toIso8601String();
                  _errorLogs.add('[$ts] $text');
                  notifyListeners();
                }

                Future<List<String>> getErrorLogs() async => List<String>.unmodifiable(_errorLogs);

                Future<void> clearErrorLogs() async {
                  _errorLogs.clear();
                  notifyListeners();
                }

                // SRS raw storage
                Future<String> getSrsRaw() async => _srsRaw;

                Future<void> setSrsRaw(String raw) async {
                  _srsRaw = raw;
                  notifyListeners();
                }

                // Reset all (Settings)
                Future<void> resetAll() async {
                  completedLessons.clear();
                  quizScores.clear();
                  _errorLogs.clear();
                  _srsRaw = '{}';
                  notifyListeners();
                }
              }
            """)
            safe_write(p, new_store)
            log(f"Replaced ProgressStore (full): {p}")
          else:
            log("Skipped: progress_store.dart not found")

          # E) Fix Course wrapper bug causing: Type 'Lesson' not found
          p = find_one("course.dart")
          if p:
            txt = safe_read(p)
            before = txt

            # If an allLessons getter mentions Lesson, rewrite it safely (no Lesson type)
            txt = re.sub(
              r"List<\s*Lesson\s*>\s+get\s+allLessons\s*=>\s*[^;]*;",
              textwrap.dedent("""\
                List<dynamic> get allLessons {
                  final out = <dynamic>[];
                  for (final m in modules) {
                    try {
                      final lessons = (m as dynamic).lessons;
                      if (lessons is Iterable) out.addAll(lessons);
                    } catch (_) {}
                  }
                  return out;
                }
              """),
              txt,
              flags=re.S,
            )

            # If Course class doesn't exist, add a SAFE one (no Module/Lesson types)
            if "class Course" not in txt:
              addon = textwrap.dedent("""\

                // --- AutoPatch FINAL v3: Course wrapper (kept dynamic to avoid missing types) ---
                class Course {
                  final String id;
                  final String title;
                  final List<dynamic> modules;

                  const Course({
                    required this.id,
                    required this.title,
                    required this.modules,
                  });

                  List<dynamic> get allLessons {
                    final out = <dynamic>[];
                    for (final m in modules) {
                      try {
                        final lessons = (m as dynamic).lessons;
                        if (lessons is Iterable) out.addAll(lessons);
                      } catch (_) {}
                    }
                    return out;
                  }
                }
              """)
              txt = txt + addon
              log(f"Appended safe Course wrapper: {p}")
            else:
              # If Course exists but our previous v2 injected Lesson, ensure no Lesson remains
              txt = txt.replace("List<Lesson> get allLessons", "List<dynamic> get allLessons")

            if txt != before:
              safe_write(p, txt)
              log(f"Patched course.dart safely: {p}")
            else:
              log(f"No course.dart patch needed: {p}")
          else:
            log("Skipped: course.dart not found")

          # F) Add ContentRepository compat methods without requiring user edits
          p = find_one("content_repository.dart")
          if p:
            txt = safe_read(p)
            if "extension ContentRepositoryCompat_FINALv3" not in txt:
              ext = textwrap.dedent("""\

                // --- AutoPatch FINAL v3: compat methods used by UI (safe/dynamic) ---
                extension ContentRepositoryCompat_FINALv3 on ContentRepository {
                  Future<Course> loadCourse() async {
                    final dynamic self = this;

                    // Try common loaders if they exist
                    for (final method in ['loadModulesFa', 'loadModules', 'getModules']) {
                      try {
                        final mods = await self.noSuchMethod(Invocation.method(Symbol(method), []));
                        if (mods is List) {
                          return Course(id: 'course', title: 'PromptCraft Academy', modules: mods);
                        }
                      } catch (_) {}
                    }

                    return const Course(id: 'course', title: 'PromptCraft Academy', modules: <dynamic>[]);
                  }

                  Future<String> loadLessonMd(String lessonId) async {
                    final dynamic self = this;
                    for (final method in ['loadLessonMarkdown', 'loadLessonMd', 'getLessonMarkdown']) {
                      try {
                        final s = await self.noSuchMethod(Invocation.method(Symbol(method), [lessonId]));
                        if (s is String) return s;
                      } catch (_) {}
                    }
                    return 'محتوای این درس پیدا نشد (lessonId=$lessonId).';
                  }
                }
              """)
              safe_write(p, txt + ext)
              log(f"Appended ContentRepository compat: {p}")
            else:
              log(f"Compat extension already present: {p}")
          else:
            log("Skipped: content_repository.dart not found")

          # Write patch report (always)
          rp = root / "patch_report.txt"
          safe_write(rp, "AutoPatch FINAL v3 report - " + datetime.utcnow().isoformat() + "Z\n\n" + "\n".join(report))
          log(f"Wrote patch_report.txt: {rp}")

          log("== AutoPatch FINAL v3 done ==")
          PY

      - name: Pub get
        working-directory: ${{ steps.root.outputs.root }}
        run: flutter pub get

      - name: Build RELEASE APKs (split per ABI + universal) + log
        working-directory: ${{ steps.root.outputs.root }}
        shell: bash
        run: |
          set -o pipefail
          flutter build apk --release --split-per-abi 2>&1 | tee flutter_build.log
          flutter build apk --release 2>&1 | tee -a flutter_build.log
          ls -lah build/app/outputs/flutter-apk || true

      - name: Collect artifacts (always)
        if: always()
        shell: bash
        env:
          ROOT: ${{ steps.root.outputs.root }}
        run: |
          mkdir -p artifacts
          cp -f "$ROOT/flutter_build.log" artifacts/flutter_build.log || true
          cp -f "$ROOT/patch_report.txt" artifacts/patch_report.txt || true
          cp -f "$ROOT/build/app/outputs/flutter-apk/"*.apk artifacts/ || true
          ls -lah artifacts || true

      - name: Upload artifacts (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: android-apk
          path: artifacts/* 
